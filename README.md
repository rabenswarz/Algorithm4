УИБО-14-24 Маркосян Тигран
Конечно! Вот переформулированный вариант текста — он звучит естественнее, но сохраняет исходный смысл и структуру:

---

# Анализ алгоритмов сортировки и поиска

## 1. Сортировка выбором (Selection Sort)

**Определение:**
Этот алгоритм делит массив на две части: отсортированную и неотсортированную. На каждом шаге ищется минимальный элемент из неотсортированной части и перемещается в начало.

**Анализ:**

* Внешний цикл выполняется `n - 1` раз.
* Внутренний цикл ищет минимальный элемент в оставшейся части.
* Всего производится примерно `n*(n-1)/2` сравнений.
  **Сложность:** `O(n²)` — из-за двух вложенных циклов, полностью зависящих от размера массива.

---

## 2. Сортировка обменом (Bubble Sort)

**Определение:**
Пузырьковая сортировка многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они расположены неправильно.

**Анализ:**

* Внешний цикл выполняется `n - 1` раз.
* В худшем случае выполняется почти `n²/2` сравнений.
* Можно ускорить работу, если отслеживать, были ли обмены в текущем проходе.
  **Сложность:**
* Худший случай — `O(n²)`
* Лучший случай (уже отсортированный массив) — `O(n)`
* Средний — `O(n²)`

---

## 3. Сортировка вставками (Insertion Sort)

**Определение:**
Формируется отсортированная часть массива, куда каждый новый элемент вставляется на своё место относительно уже упорядоченных элементов.

**Анализ:**

* Каждый элемент сравнивается с предыдущими и сдвигается до нужной позиции.
* В худшем случае количество сравнений и сдвигов ≈ `n*(n-1)/2`.
  **Сложность:**
* Худший случай — `O(n²)`
* Лучший случай (почти отсортированные данные) — `O(n)`
* Средний — `O(n²)`

---

## 4. Сортировка слиянием (Merge Sort)

**Определение:**
Рекурсивный алгоритм, работающий по принципу «разделяй и властвуй»: массив делится пополам, каждая часть сортируется отдельно, после чего они объединяются в отсортированный результат.

**Анализ:**

* Глубина рекурсии — `log n`.
* На каждом уровне обрабатывается `O(n)` элементов.
  **Сложность:** `O(n log n)`
  (во всех случаях — благодаря сбалансированной структуре вызовов).

---

## 5. Сортировка Шелла (Shell Sort)

**Определение:**
Улучшенный вариант сортировки вставками, где элементы сравниваются на определённом расстоянии (gap), которое постепенно уменьшается до 1.

**Анализ:**

* Эффективность зависит от выбранной последовательности шагов (gap).
* При делении шага пополам (n/2, n/4, …) сложность находится между `O(n^(3/2))` и `O(n log² n)`.
  **Сложность:**
* Средняя — около `O(n^(3/2))`
* Худшая — `O(n²)`

---

## 6. Быстрая сортировка (Quick Sort)

**Определение:**
Быстрая сортировка основана на выборе опорного элемента (pivot). Массив делится на элементы меньше и больше опорного, затем обе части сортируются рекурсивно.

**Анализ:**

* При хорошем выборе опорного массив делится примерно пополам.
* При неудачном — превращается в цепочку рекурсий.
  **Сложность:**
* Средняя и лучшая — `O(n log n)`
* Худшая — `O(n²)`

---

## 7. Пирамидальная сортировка (Heap Sort)

**Определение:**
Использует структуру «двоичная куча». Сначала строится куча, затем из неё поочерёдно извлекаются максимальные элементы, которые помещаются в конец массива.

**Анализ:**

* Построение кучи занимает `O(n)`.
* Каждый вызов `heapify` после удаления — `O(log n)`.
  **Сложность:** `O(n log n)`
  (во всех случаях).

---

## 8. Последовательный поиск (Linear Search)

**Определение:**
Простейший метод поиска, при котором элементы проверяются один за другим до тех пор, пока не будет найден нужный.

**Анализ:**

* В худшем случае нужно пройти все элементы.
* В лучшем — элемент найден сразу.
  **Сложность:**
* Худший — `O(n)`
* Лучший — `O(1)`

---

## 9. Бинарный поиск (Binary Search)

**Определение:**
Работает только с отсортированными массивами. Делит диапазон пополам и продолжает поиск в той половине, где может находиться элемент.

**Анализ:**

* На каждом шаге размер диапазона уменьшается вдвое.
  **Сложность:** `O(log n)`

---

## 10. Интерполяционный поиск (Interpolation Search)

**Определение:**
Модификация бинарного поиска, которая пытается предсказать позицию элемента, исходя из его значения и распределения данных.

**Анализ:**

* Быстрее бинарного при равномерном распределении.
* При неравномерных данных может работать как линейный поиск.
  **Сложность:**
* Средняя — `O(log log n)`
* Худшая — `O(n)`

---

## 11. Поиск по Фибоначчи (Fibonacci Search)

**Определение:**
Поиск по Фибоначчи похож на бинарный, но использует числа Фибоначчи для определения точек деления диапазона.

**Анализ:**

* На каждом шаге диапазон сокращается, используя последовательность Фибоначчи.
  **Сложность:** `O(log n)`
